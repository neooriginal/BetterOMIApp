<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title><%= title %> - GenOmi</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
  <link rel="stylesheet" href="/css/styles.css">
  <style>
    #visualization-container {
      width: 100%;
      height: 80vh;
      position: relative;
      overflow: hidden;
      background-color: #000;
      border-radius: 8px;
    }
    
    #visualization-info {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      max-width: 300px;
      z-index: 100;
    }
    
    #loading-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 1.2rem;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      z-index: 100;
    }
    
    .legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 5px;
      z-index: 100;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 0;
    }
    
    .legend-color {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-primary">
    <div class="container">
      <a class="navbar-brand" href="/">GenOmi</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item">
            <a class="nav-link" href="/input">Input</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/action-items">Action Items</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/memories">Memories</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="/transcriptions">Transcriptions</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" href="/brain">Brain</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <!-- Main Content -->
  <div class="container py-4">
    <div class="d-flex justify-content-between align-items-center mb-4">
      <h1 class="mb-0">Brain Visualization</h1>
      <div>
        <button id="resetCamera" class="btn btn-outline-primary me-2">
          <i class="bi bi-arrow-counterclockwise"></i> Reset View
        </button>
        <button id="toggleFilter" class="btn btn-outline-secondary">
          <i class="bi bi-funnel"></i> Filter
        </button>
      </div>
    </div>
    
    <!-- Filter Controls (hidden by default) -->
    <div id="filterControls" class="card shadow-sm mb-4" style="display: none;">
      <div class="card-body">
        <div class="row">
          <div class="col-md-3 mb-3">
            <label class="form-label">Node Types</label>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" value="person" id="filterPerson" checked>
              <label class="form-check-label" for="filterPerson">People</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" value="location" id="filterLocation" checked>
              <label class="form-check-label" for="filterLocation">Locations</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" value="event" id="filterEvent" checked>
              <label class="form-check-label" for="filterEvent">Events</label>
            </div>
            <div class="form-check">
              <input class="form-check-input" type="checkbox" value="activity" id="filterActivity" checked>
              <label class="form-check-label" for="filterActivity">Activities</label>
            </div>
          </div>
          <div class="col-md-5 mb-3">
            <label class="form-label">Importance</label>
            <div class="d-flex">
              <input type="range" class="form-range" min="1" max="5" step="1" id="importanceSlider" value="1">
              <span id="importanceValue" class="ms-2">1+</span>
            </div>
            <small class="text-muted">Show nodes with importance greater than or equal to selected value</small>
          </div>
          <div class="col-md-4 mb-3">
            <label class="form-label">Search</label>
            <input type="text" class="form-control" id="searchNodes" placeholder="Search node names...">
          </div>
        </div>
        <div class="d-flex justify-content-end">
          <button id="applyFilters" class="btn btn-primary">Apply Filters</button>
        </div>
      </div>
    </div>
    
    <!-- Visualization Container -->
    <div id="visualization-container" class="shadow">
      <div id="loading-indicator">
        <div class="spinner-border text-light me-2" role="status"></div>
        Loading brain data...
      </div>
      
      <!-- Node Info Panel (hidden initially) -->
      <div id="visualization-info" style="display: none;">
        <h5 id="node-name">Select a node</h5>
        <p id="node-type" class="mb-1"><small></small></p>
        <p id="node-importance" class="mb-1"><small></small></p>
        <div id="node-details"></div>
      </div>
      
      <!-- Legend -->
      <div class="legend">
        <h6 class="mb-2">Legend</h6>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #FF5555;"></div>
          <span>People</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #55FF55;"></div>
          <span>Locations</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #5555FF;"></div>
          <span>Events</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #FFAA00;"></div>
          <span>Activities</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.156.1/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.8.1/dist/three-spritetext.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const container = document.getElementById('visualization-container');
      const loadingIndicator = document.getElementById('loading-indicator');
      const nodeInfo = document.getElementById('visualization-info');
      const nodeName = document.getElementById('node-name');
      const nodeType = document.getElementById('node-type');
      const nodeImportance = document.getElementById('node-importance');
      const nodeDetails = document.getElementById('node-details');
      
      // Filter controls
      const toggleFilterBtn = document.getElementById('toggleFilter');
      const filterControls = document.getElementById('filterControls');
      const importanceSlider = document.getElementById('importanceSlider');
      const importanceValue = document.getElementById('importanceValue');
      const searchNodes = document.getElementById('searchNodes');
      const typeCheckboxes = {
        person: document.getElementById('filterPerson'),
        location: document.getElementById('filterLocation'),
        event: document.getElementById('filterEvent'),
        activity: document.getElementById('filterActivity')
      };
      
      // Initialize Three.js scene
      let scene, camera, renderer, controls;
      let raycaster, mouse;
      let brainData = null;
      let nodeObjects = new Map(); // Map node IDs to THREE objects
      let selectedNode = null;
      
      // Node type to color mapping
      const typeColors = {
        person: 0xFF5555,    // Red
        location: 0x55FF55,  // Green
        event: 0x5555FF,     // Blue
        activity: 0xFFAA00   // Orange
      };
      
      // Initialize Three.js scene
      function initScene() {
        // Create scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // Create camera
        camera = new THREE.PerspectiveCamera(
          75, 
          container.clientWidth / container.clientHeight, 
          0.1, 
          1000
        );
        camera.position.z = 30;
        
        // Create renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        // Add orbit controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Setup raycaster for interaction
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        
        // Add event listeners
        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onClick);
        
        // Add ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        // Add directional light
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);
        
        // Start animation loop
        animate();
      }
      
      // Handle window resize
      function onWindowResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }
      
      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      
      // Handle mouse click for node selection
      function onClick(event) {
        // Calculate mouse position in normalized device coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // Update the picking ray with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);
        
        // Calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects(scene.children, true);
        
        if (intersects.length > 0) {
          // Check if we clicked on a node
          const clickedObject = intersects[0].object;
          if (clickedObject.userData && clickedObject.userData.nodeId) {
            // Find the node with this ID
            const node = brainData.nodes.find(n => n.id === clickedObject.userData.nodeId);
            if (node) {
              // Show node details
              showNodeDetails(node);
              
              // Highlight selected node
              if (selectedNode) {
                const prevObject = nodeObjects.get(selectedNode.id);
                if (prevObject) {
                  prevObject.material.emissive.setHex(0x000000);
                }
              }
              
              selectedNode = node;
              clickedObject.material.emissive.setHex(0x333333);
            }
          }
        } else {
          // Clear selection if clicked on empty space
          if (selectedNode) {
            const prevObject = nodeObjects.get(selectedNode.id);
            if (prevObject) {
              prevObject.material.emissive.setHex(0x000000);
            }
            selectedNode = null;
            hideNodeDetails();
          }
        }
      }
      
      // Display node details in the info panel
      function showNodeDetails(node) {
        nodeInfo.style.display = 'block';
        nodeName.textContent = node.name;
        nodeType.textContent = capitalizeFirstLetter(node.type);
        nodeImportance.textContent = `Importance: ${node.importance}`;
        
        // Clear previous details
        nodeDetails.innerHTML = '';
        
        // Add node-specific details
        if (node.data) {
          let html = '<div class="mt-2">';
          
          if (node.type === 'person' && node.data.role) {
            html += `<p class="mb-1"><small>Role: ${node.data.role}</small></p>`;
          } else if (node.type === 'location' && typeof node.data === 'string') {
            html += `<p class="mb-1"><small>Details: ${node.data}</small></p>`;
          } else if ((node.type === 'event' || node.type === 'activity') && node.data.description) {
            html += `<p class="mb-1"><small>Description: ${node.data.description}</small></p>`;
            
            if (node.data.date) {
              html += `<p class="mb-1"><small>Date: ${node.data.date}</small></p>`;
            }
          }
          
          html += '</div>';
          nodeDetails.innerHTML = html;
        }
        
        // Find related nodes
        const connectedLinks = brainData.links.filter(
          link => link.source === node.id || link.target === node.id
        );
        
        if (connectedLinks.length > 0) {
          let relationshipsHtml = '<div class="mt-3"><h6>Relationships:</h6><ul class="small ps-3 mb-0">';
          
          connectedLinks.forEach(link => {
            const isSource = link.source === node.id;
            const otherNodeId = isSource ? link.target : link.source;
            const otherNode = brainData.nodes.find(n => n.id === otherNodeId);
            
            if (otherNode) {
              let relationshipDescription;
              if (isSource) {
                relationshipDescription = `${link.type} ${otherNode.name}`;
              } else {
                relationshipDescription = `${otherNode.name} ${link.type} this ${node.type}`;
              }
              
              relationshipsHtml += `<li>${relationshipDescription}</li>`;
            }
          });
          
          relationshipsHtml += '</ul></div>';
          nodeDetails.innerHTML += relationshipsHtml;
        }
      }
      
      // Hide node details panel
      function hideNodeDetails() {
        nodeInfo.style.display = 'none';
        nodeName.textContent = 'Select a node';
        nodeType.textContent = '';
        nodeImportance.textContent = '';
        nodeDetails.innerHTML = '';
      }
      
      // Helper function to capitalize first letter
      function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
      
      // Load brain data from the API
      async function loadBrainData() {
        try {
          const response = await fetch('/brain/data');
          const result = await response.json();
          
          if (result.success) {
            brainData = result.data;
            createVisualization(brainData);
            loadingIndicator.style.display = 'none';
          } else {
            console.error('Failed to load brain data:', result.message);
            loadingIndicator.textContent = 'Error loading brain data';
          }
        } catch (error) {
          console.error('Error loading brain data:', error);
          loadingIndicator.textContent = 'Error loading brain data';
        }
      }
      
      // Create the 3D visualization
      function createVisualization(data) {
        // Clear any existing nodes
        while (scene.children.length > 0) {
          scene.remove(scene.children[0]);
        }
        nodeObjects.clear();
        
        // Add lights back
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(0, 1, 1);
        scene.add(directionalLight);
        
        // Create a 3D force-directed layout
        const nodes = JSON.parse(JSON.stringify(data.nodes));
        const links = JSON.parse(JSON.stringify(data.links));
        
        // Assign initial random positions
        nodes.forEach(node => {
          node.x = (Math.random() - 0.5) * 40;
          node.y = (Math.random() - 0.5) * 40;
          node.z = (Math.random() - 0.5) * 40;
        });
        
        // Simple force simulation (can be more complex in real implementation)
        for (let i = 0; i < 100; i++) {
          simulateForces(nodes, links);
        }
        
        // Create node objects
        nodes.forEach(node => {
          // Base size on importance
          const size = 0.5 + node.importance * 0.3;
          
          // Create sphere geometry
          const geometry = new THREE.SphereGeometry(size, 16, 16);
          
          // Create material with color based on node type
          const material = new THREE.MeshPhongMaterial({
            color: typeColors[node.type] || 0xFFFFFF,
            specular: 0x444444,
            shininess: 30
          });
          
          // Create mesh
          const mesh = new THREE.Mesh(geometry, material);
          mesh.position.set(node.x, node.y, node.z);
          mesh.userData.nodeId = node.id;
          scene.add(mesh);
          nodeObjects.set(node.id, mesh);
          
          // Add node label
          const label = new THREE.SpriteText(node.name, 1.5);
          label.position.set(node.x, node.y + size + 1, node.z);
          label.color = 'white';
          label.backgroundColor = 'rgba(0,0,0,0.2)';
          label.padding = [0.2, 0.5];
          label.borderRadius = 0.2;
          label.borderWidth = 0;
          label.fontSize = 0.8;
          label.fontWeight = '500';
          label.userData.nodeId = node.id;
          scene.add(label);
        });
        
        // Create links between nodes
        links.forEach(link => {
          const sourceNode = nodes.find(n => n.id === link.source);
          const targetNode = nodes.find(n => n.id === link.target);
          
          if (sourceNode && targetNode) {
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute([
              sourceNode.x, sourceNode.y, sourceNode.z,
              targetNode.x, targetNode.y, targetNode.z
            ], 3));
            
            const material = new THREE.LineBasicMaterial({
              color: 0x888888,
              transparent: true,
              opacity: 0.5
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
          }
        });
      }
      
      // Simple force-directed layout algorithm
      function simulateForces(nodes, links) {
        // Repulsive forces between all nodes
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const dx = nodes[i].x - nodes[j].x;
            const dy = nodes[i].y - nodes[j].y;
            const dz = nodes[i].z - nodes[j].z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
            
            if (distance < 10) {
              const repulsiveForce = 1 / (distance * distance);
              const fx = (dx / distance) * repulsiveForce;
              const fy = (dy / distance) * repulsiveForce;
              const fz = (dz / distance) * repulsiveForce;
              
              nodes[i].x += fx * 0.2;
              nodes[i].y += fy * 0.2;
              nodes[i].z += fz * 0.2;
              
              nodes[j].x -= fx * 0.2;
              nodes[j].y -= fy * 0.2;
              nodes[j].z -= fz * 0.2;
            }
          }
        }
        
        // Attractive forces along links
        links.forEach(link => {
          const sourceNode = nodes.find(n => n.id === link.source);
          const targetNode = nodes.find(n => n.id === link.target);
          
          if (sourceNode && targetNode) {
            const dx = targetNode.x - sourceNode.x;
            const dy = targetNode.y - sourceNode.y;
            const dz = targetNode.z - sourceNode.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz) || 1;
            
            // Ideal distance is 5
            const attractiveForce = (distance - 5) / 15;
            
            const fx = (dx / distance) * attractiveForce;
            const fy = (dy / distance) * attractiveForce;
            const fz = (dz / distance) * attractiveForce;
            
            sourceNode.x += fx;
            sourceNode.y += fy;
            sourceNode.z += fz;
            
            targetNode.x -= fx;
            targetNode.y -= fy;
            targetNode.z -= fz;
          }
        });
      }
      
      // Apply filters
      function applyFilters() {
        const minImportance = parseInt(importanceSlider.value);
        const searchTerm = searchNodes.value.toLowerCase().trim();
        const activeTypes = Object.entries(typeCheckboxes)
          .filter(([_, checkbox]) => checkbox.checked)
          .map(([type, _]) => type);
        
        if (!brainData) return;
        
        // Create filtered nodes and links
        const filteredNodes = brainData.nodes.filter(node => {
          // Check node type
          if (!activeTypes.includes(node.type)) return false;
          
          // Check importance
          if (node.importance < minImportance) return false;
          
          // Check search term
          if (searchTerm && !node.name.toLowerCase().includes(searchTerm)) return false;
          
          return true;
        });
        
        const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
        
        const filteredLinks = brainData.links.filter(link => 
          filteredNodeIds.has(link.source) && filteredNodeIds.has(link.target)
        );
        
        // Recreate visualization with filtered data
        createVisualization({
          nodes: filteredNodes,
          links: filteredLinks
        });
      }
      
      // Initialize the scene
      initScene();
      
      // Load the data
      loadBrainData();
      
      // Event listeners for UI controls
      document.getElementById('resetCamera').addEventListener('click', () => {
        camera.position.set(0, 0, 30);
        controls.reset();
      });
      
      toggleFilterBtn.addEventListener('click', () => {
        filterControls.style.display = filterControls.style.display === 'none' ? 'block' : 'none';
      });
      
      importanceSlider.addEventListener('input', () => {
        importanceValue.textContent = `${importanceSlider.value}+`;
      });
      
      document.getElementById('applyFilters').addEventListener('click', applyFilters);
    });
  </script>
</body>
</html> 